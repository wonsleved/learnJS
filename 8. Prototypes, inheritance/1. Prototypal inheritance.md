# Prototypal inheritance

*Prototypal* inheritance is a language feature that helps in that.

## [[Prototype]]

In JavaScript, objects have a special hidden property `[[Prototype]]` (as named in the specification), that is either `null` or references another object. That object is called “a prototype”

When we read a property from `object`, and it’s missing, JavaScript automatically takes it from the prototype. In programming, this is called “prototypal inheritance”.

The property `[[Prototype]]` is internal and hidden.

The way to set it:

```
objA.__proto__ = objB;
```

There are only two limitations:

1. The references can’t go in circles. JavaScript will throw an error if we try to assign `__proto__` in a circle. 
2. The value of `__proto__` can be either an object or `null`. Other types are ignored.

**There can be only one `[[Prototype]]`**

***`__proto__` is a historical getter/setter for `[[Prototype]]`***

Modern JavaScript suggests that we should use `Object.getPrototypeOf/Object.setPrototypeOf` functions instead that get/set the prototype.

## Writing doesn’t use prototype

The prototype is only used for reading properties. Write/delete operations work directly with the object.

## The value of “this”

**No matter where the method is found: in an object or its prototype. In a method call, `this` is always the object before the dot.**

## for…in loop

The `for..in` loop iterates over inherited properties too.

`obj.hasOwnProperty(key)` - returns `true` if `obj` has its own (not inherited) property named `key`.
