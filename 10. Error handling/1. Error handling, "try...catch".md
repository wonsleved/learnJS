# Error handling, "try...catch"

Usually, a script “dies” (immediately stops) in case of an error, printing it to console.

## The “try…catch” syntax

It works like this:

1. First, the code in `try {...}` is executed. 
2. If there were no errors, then `catch (err)` is ignored: the execution reaches the end of `try` and goes on, skipping `catch`. 
3. If an error occurs, then the `try` execution is stopped, and control flows to the beginning of `catch (err)`. The `err` variable (we can use any name for it) will contain an error object with details about what happened.

***`try...catch` only works for runtime errors.***
It won’t work if the code is syntactically wrong, for instance it has unmatched curly braces.

***`try...catch` works synchronously.***
If an exception happens in “scheduled” code, like in `setTimeout`, then `try...catch` won’t catch it.
That’s because the function itself is executed later, when the engine has already left the `try...catch` construct

## Error object

For all built-in errors, the error object has two main properties:

- `name` - error name. For instance, for an undefined variable that’s "ReferenceError".
- `message` - textual message about error details.

Non-standard properties available in most environments:

- `stack` - current call stack: a string with information about the sequence of nested calls that led to the error.


## Optional “catch” binding

If we don’t need error details, `catch` may omit it:

```
try {
  // ...
} catch { // <-- without (err)
  // ...
}
```

## Using “try…catch”

**If `json` is malformed, `JSON.parse` generates an error, so the script “dies”.**

## Throwing our own errors

### “Throw” operator

```
throw <error object>
```

Technically, we can use anything as an error object. That may be even a primitive.

Standard errors: `Error`, `SyntaxError`, `ReferenceError`, `TypeError` and others.

The `name` property is exactly the name of the constructor. And `message` is taken from the argument.

## Rethrowing

**Catch should only process errors that it knows and “rethrow” all others.**

The “rethrowing” technique can be explained in more detail as:

1. Catch gets all errors. 
2. In the `catch (err) {...}` block we analyze the error object `err`. 
3. If we don’t know how to handle it, we do `throw err`.

We can check the error type using the `instanceof` operator.

## try…catch…finally

If it exists, it runs in all cases:

- after `try`, if there were no errors,
- after `catch`, if there were errors.

***Variables are local inside `try...catch...finally`***

***`finally` and `return`.***

The `finally` clause works for any exit from `try...catch`. That includes an explicit return.

```
function func() {

  try {
    return 1;

  } catch (err) {
    /* ... */
  } finally {
    alert( 'finally' );
  }
}

alert( func() ); // first works alert from finally, and then this one
```


## Global catch

```
window.onerror = function(message, url, line, col, error) {
  // ...
};
```


- message - error message. 
- url - URL of the script where error happened.
- line, col - line and column numbers where error happened.
- error - error object.



