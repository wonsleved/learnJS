# Generators

## Generator functions

To create a generator, we need a special syntax construct: `function*`, so-called “generator function”.

```
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
```

It returns a special object, called “generator object”.

The main method of a generator is `next()`. When called, it runs the execution until the nearest `yield <value>` statement (`value` can be omitted, then it’s `undefined`). Then the function execution pauses, and the yielded `value` is returned to the outer code.

The result of `next()` is always an object with two properties:

- `value`: the yielded value. 
- `done`: true if the function code has finished, otherwise `false`.

```
function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

let one = generator.next();

alert(JSON.stringify(one)); // {value: 1, done: false}
```

## Generators are iterable

```
for(let value of generator) {
  alert(value); // 1, then 2
}
```

`for..of` iteration ignores the last value, when done: true. (where `return` statement).

```
let sequence = [0, ...generateSequence()];
alert(sequence); // 0, 1, 2, 3
```

## Using generators for iterables

We can use a generator function for iteration by providing it as `Symbol.iterator`.

```
let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // a shorthand for [Symbol.iterator]: function*()
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

alert( [...range] ); // 1,2,3,4,5
```

***Generators may generate values forever***

## Generator composition

For generators, there’s a special `yield*` syntax to “embed” (compose) one generator into another.

The `yield*` directive delegates the execution to another generator.

```
function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generatePasswordCodes() {

  // 0..9
  yield* generateSequence(48, 57);

  // A..Z
  yield* generateSequence(65, 90);

  // a..z
  yield* generateSequence(97, 122);

} // 0..9A..Za..z
```

A generator composition is a natural way to insert a flow of one generator into another. It doesn’t use extra memory to store intermediate results.

## “yield” is a two-way street

We should call `generator.next(arg)`, with an argument. That argument becomes the result of `yield`.

## generator.throw

To pass an error into a `yield`, we should call `generator.throw(err)`. In that case, the `err` is thrown in the line with that `yield`.

## generator.return

`generator.return(value)` finishes the generator execution and return the given `value`.

If we again use `generator.return()` in a completed generator, it will return that value again ([MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return)).

