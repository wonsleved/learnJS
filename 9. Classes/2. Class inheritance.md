# Class inheritance

Class inheritance is a way for one class to extend another class.

## The “extends” keyword.

The syntax to extend another class is: class `Child extends Parent`.

Internally, extends keyword works using the good old prototype mechanics. It sets `Rabbit.prototype`.`[[Prototype]]` to `Animal.prototype`.

***Any expression is allowed after extends.***

```
function f(phrase) {
  return class {
    sayHi() { alert(phrase); }
  };
}

class User extends f("Hello") {}

new User().sayHi(); // Hello
```

## Overriding a method

Classes provide `"super"` keyword for that.

- `super.method(...)` to call a parent method.
- `super(...)` to call a parent constructor (inside our constructor only).

***Arrow functions have no super.***
If accessed, it’s taken from the outer function.

## Overriding constructor

If a class extends another class and has no `constructor`, then the following “empty” `constructor` is generated:

```
class Rabbit extends Animal {
  // generated for extending classes without own constructors
  constructor(...args) {
    super(...args);
  }
}
```

**Constructors in inheriting classes must call `super(...)`, and (!) do it before using `this`.**

A derived constructor has a special internal property `[[ConstructorKind]]:"derived"`.

That label affects its behavior with `new`.

- When a regular function is executed with `new`, it creates an empty object and assigns it to `this`.
- But when a derived constructor runs, it doesn’t do this. It expects the parent constructor to do this job.

## Overriding class fields: a tricky note

**The parent constructor always uses its own field value, not the overridden one.**

The class field is initialized:

- Before constructor for the base class (that doesn’t extend anything), 
- Immediately after `super()` for the derived class.

## Super: internals, `[[HomeObject]]`

The problem can’t be solved by using `this` alone.

## `[[HomeObject]]`

JavaScript adds one more special internal property for functions: `[[HomeObject]]`.

When a function is specified as a class or object method, its `[[HomeObject]]` property becomes that object.

`super` uses it to resolve the parent prototype and its methods.

## Methods are not “free”

Generally functions are “free”, not bound to objects in JavaScript. So they can be copied between objects and called with another `this`.

The very existence of `[[HomeObject]]` violates that principle, because methods remember their objects. `[[HomeObject]]` can’t be changed, so this bond is forever.

## Methods, not function properties

`[[HomeObject]]` is defined for methods both in classes and in plain objects. But for objects, methods must be specified exactly as `method()`, not as `"method: function()"`.

```
let animal = {
  eat: function() { // intentionally writing like this instead of eat() {...
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // Error calling super (because there's no [[HomeObject]])
```








