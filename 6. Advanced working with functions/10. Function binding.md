# Function binding

When passing object methods as callbacks, for instance to `setTimeout`, there’s a known problem: "losing `this`".

## Losing “this”

```
let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
```

That’s because `setTimeout` got the function `user.sayHi`, separately from the object.

The method `setTimeout` in-browser is a little special: it sets `this=window` for the function call.

## Solution 1: a wrapper

```
setTimeout(() => user.sayHi(), 1000); // Hello, John!
```

What if before `setTimeout` triggers (there’s one second delay!) `user` changes value? Then, suddenly, it will call the wrong object!

## Solution 2: bind

```
// more complex syntax will come a little later
let boundFunc = func.bind(context);
```

***Convenience method: `bindAll`.***

## Partial functions

```
function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
```

## Going partial without context

```
function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}
```