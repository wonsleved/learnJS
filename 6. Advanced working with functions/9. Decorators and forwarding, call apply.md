# Decorators and forwarding, call/apply

Decorator is a wrapper around a function that alters its behavior. The main job is still carried out by the function.

Decorators can be seen as “features” or “aspects” that can be added to a function. We can add one or add many. And all this without changing its code!

To implement `cachingDecorator`, we studied methods:
- `func.call(context, arg1, arg2…)` – calls func with given context and arguments.
- `func.apply(context, args)` – calls func passing context as this and array-like args into a list of arguments.

The generic call forwarding is usually done with `apply`:

```
let wrapper = function() {
  return original.apply(this, arguments);
};
```

## Borrowing a method

```
function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
```

We take (borrow) a join method from a regular array (`[].join`) and use `[].join.call` to run it in the context of arguments.

