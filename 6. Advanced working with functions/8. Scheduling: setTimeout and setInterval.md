# Scheduling: setTimeout and setInterval

- `setTimeout` allows us to run a function once after the interval of time.
- `setInterval` allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval.

## setTimeout

```
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...)
```

***Pass a function, but don’t run it***

### Canceling with clearTimeout

A call to setTimeout returns a “timer identifier” timerId that we can use to cancel the execution.

```
let timerId = setTimeout(...);
clearTimeout(timerId);
alert(timerId); // same identifier (doesn't become null after canceling)
```

In a browser the timer identifier is a number. Node.js returns a timer object with additional methods.

## setInterval

```
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...)
```

To stop further calls, we should call `clearInterval(timerId)`.

***Time goes on while `alert` is shown***

## Nested setTimeout

One is `setInterval`. The other one is a nested `setTimeout`:

```
/** instead of:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

**Nested `setTimeout` allows to set the delay between the executions more precisely than `setInterval`.**

**The nested `setTimeout` guarantees the fixed delay (here 100ms).**

***Garbage collection and setInterval/setTimeout callback***

When a function is passed in `setInterval/setTimeout`, an internal reference is created to it and saved in the scheduler. It prevents the function from being garbage collected, even if there are no other references to it.

For `setInterval` the function stays in memory until clearInterval is called.

A function references the outer lexical environment, so, while it lives, outer variables live too.

## Zero delay setTimeout

There’s a special use case: `setTimeout(func, 0)`, or just `setTimeout(func)`.

***Zero delay is in fact not zero (in a browser)***
The browser limits the minimal delay for five or more nested calls of setTimeout or for setInterval (after 5th call) to 4ms. That’s for historical reasons.

The in-browser timer may slow down for a lot of reasons:

- The CPU is overloaded.
- The browser tab is in the background mode.
- The laptop is on battery.



