# Array methods

### splice

The arrays are objects, so we can try to use `delete`. But the empty cell remains.

```
arr.splice(start[, deleteCount, elem1, ..., elemN])
```

It modifies `arr` starting from the index `start`: removes `deleteCount` elements and then inserts `elem1, ..., elemN` at their place. Returns the array of removed elements.

***Negative indexes allowed.***
They specify the position from the end of the array.

### slice

```
arr.slice([start], [end])
```

It returns a new array copying to it all items from index `start` to `end` (not including `end`). Both `start` and `end` can be negative, in that case position from array end is assumed.

### concat

```
arr.concat(arg1, arg2...)
```

The result is a new array containing items from `arr`, then `arg1`, `arg2` etc.

If an argument argN is an array, then all its elements are copied.

If an array-like object has a special `Symbol.isConcatSpreadable` property, then it’s treated as an array by concat..

```
let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
```

## Iterate: forEach

The `arr.forEach` method allows to run a function for every element of the array.

## Searching in array

### indexOf/lastIndexOf and includes

- `arr.indexOf(item, from)` – looks for `item` starting from index `from`, and returns the index where it was found, otherwise `-1`. 
- `arr.lastIndexOf(item, from)` – same, but looks for from right to left. 
- `arr.includes(item, from)` – looks for `item` starting from index `from`, returns `true` if found.

Methods use === comparison.

A very minor difference of `includes` is that it correctly handles `NaN`, unlike `indexOf/lastIndexOf`.

### find and findIndex

```
let result = arr.find(function(item, index, array) {
  // if true is returned, item is returned and iteration is stopped
  // for falsy scenario returns undefined
});
```

### filter

```
let results = arr.filter(function(item, index, array) {
  // if true item is pushed to results and the iteration continues
  // returns empty array if nothing found
});
```

## Transform an array

### map

```
let result = arr.map(function(item, index, array) {
  // returns the new value instead of item
});
```

### sort(func)

The call to `arr.sort()` sorts the array in place, changing its element order.

**The items are sorted as strings by default.**

```
function compare(a, b) {
  if (a > b) return 1; // if the first value is greater than the second
  if (a == b) return 0; // if values are equal
  if (a < b) return -1; // if the first value is less than the second
}
```

***A comparison function may return any number.***

***Arrow functions for the best.***

```
arr.sort( (a, b) => a - b );
```

***Use `localeCompare` for strings***

### reverse

The method `arr.reverse` reverses the order of elements in `arr`.

It also returns the array `arr` after the reversal.

### split and join

- The `str.split(delim)` method does exactly that. It splits the string into an array by the given delimiter `delim`.

***Split into letters***

```
alert( str.split('') );
```

- The call `arr.join(glue)` does the reverse to `split`. It creates a string of `arr` items joined by `glue` between them.

## reduce/reduceRight

They are used to calculate a single value based on the array.

```
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
```

- `accumulator` – is the result of the previous function call, equals initial the first time (if initial is provided). 
- `item` – is the current array item. 
- `index` – is its position. 
- `array` – is the array.

If there’s no initial, then `reduce` takes the first element of the array as the initial value and starts the iteration from the 2nd element.

If the array is empty, then `reduce` call without initial value gives an error.

The method `arr.reduceRight` does the same, but goes from right to left.

## Array.isArray

```
alert(typeof {}); // object
alert(typeof []); // same
```

```
alert(Array.isArray({})); // false
alert(Array.isArray([])); // true
```

## Most methods support “thisArg”

Almost all array methods that call functions – like `find`, `filter`, `map`, with a notable exception of `sort`, accept an optional additional parameter `thisArg`.

```
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
```

The value of `thisArg` parameter becomes `this` for `func`.

*** 

- `arr.some(fn)/arr.every(fn)` - check the array.

The function `fn` is called on each element of the array similar to `map`. If any/all results are `true`, returns `true`, otherwise `false`.

- `arr.fill(value, start, end)` – fills the array with repeating `value` from index `start` to `end`.
- `arr.copyWithin(target, start, end)` – copies its elements from position `start` till position `end` into itself, at position `target` (overwrites existing).
- `arr.flat(depth)/arr.flatMap(fn)` create a new flat array from a multidimensional array.