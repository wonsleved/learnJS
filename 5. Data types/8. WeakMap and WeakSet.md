# WeakMap and WeakSet

## WeakMap

The first difference between `Map` and `WeakMap` is that keys must be objects, not primitive values.

Now, if we use an object as the key in it, and there are no other references to that object – it will be removed from memory (and from the map) automatically.

`WeakMap` has only the following methods:

- `weakMap.get(key)`
- `weakMap.set(key, value)`
- `weakMap.delete(key)`
- `weakMap.has(key)`

Why such a limitation? That’s for technical reasons.

## Use case: additional data

The main area of application for `WeakMap` is an *additional data storage*.
Use it to store some data when another data is available.

## Use case: caching

Another common example is caching. We can store (“cache”) results from a function, so that future calls on the same object can reuse it.

```
let cache = new Map();

// calculate and remember the result
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calculations of the result for */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}
```

## WeakSet

`WeakSet` behaves similarly.

Being “weak”, it also serves as additional storage. But not for arbitrary data, rather for “yes/no” facts. A membership in `WeakSet` may mean something about the object.



