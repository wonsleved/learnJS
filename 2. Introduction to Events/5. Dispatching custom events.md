# Dispatching custom events

We can not only assign handlers, but also generate events from JavaScript.

## Event constructor

```
let event = new Event(type[, options]);
```

- _type_ – event type, a string like `"click"` or our own like `"my-event"`.
- _options_ – the object with two optional properties:
  - `bubbles: true/false` – if `true`, then the event bubbles. 
  - `cancelable: true/false` – if `true`, then the “default action” may be prevented.
  
By default, both are false.


## dispatchEvent

After an event object is created, we should “run” it on an element using the call `elem.dispatchEvent(event)`.

***event.isTrusted.***
`false` for script-generated.

## Bubbling example

***`on<event>` only exists for built-in events.***

## MouseEvent, KeyboardEvent and others

Classes for UI Events from the [UI Event specification](https://www.w3.org/TR/uievents)

- `UIEvent`
- `FocusEvent`
- `MouseEvent`
- `WheelEvent`
- `KeyboardEvent` 

We should use them instead of `new Event`.

The right constructor allows to specify standard properties for that type of event.

```
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});
```

## Custom events

We should use `new CustomEvent` for our own.

In the second argument (object) we can add an additional property detail for any custom information that we want to pass with the event.

```
elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "John" }
  }));
```

## event.preventDefault()

By calling `event.preventDefault()`, an event handler may send a signal that those actions should be canceled.

In that case the call to `elem.dispatchEvent(event)` returns false.

The event must have the flag `cancelable: true`, otherwise the call `event.preventDefault()` is ignored.

## Events-in-events are synchronous

Usually events are processed in a queue.

Nested events are processed immediately. Not only for `dispatchEvent`.

If an event handler calls methods that trigger other events – they are processed synchronously too





